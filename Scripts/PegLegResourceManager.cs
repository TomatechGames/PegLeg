using Godot;
using System;
using System.Collections.Concurrent;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Threading.Tasks;

public class PegLegResourceManager
{
    public const string packageFolderPath = "user://Resources/";
    public const string resourcePath = "res://PegLegResources/";
    public const string fallbackResourcePath = "res://FallbackResources/";
    public const string overrideResourcePath = "user://CustomResources/";

    public static readonly Texture2D defaultIcon = ResourceLoader.Load<Texture2D>("res://Images/InterfaceIcons/T-Icon-Unknown-128.png");
    public static readonly BanjoSuppliments supplimentaryData = ResourceLoader.Load<BanjoSuppliments>("res://banjo_suppliments.tres");

    static FrozenDictionary<string, JsonObject> dataSources;
    public static FrozenDictionary<string, JsonObject> itemSources { get; private set; }
    
    //TODO: platform specific substitutions (Win64/Linux)
    static RegEx versionRegex;
    static RegEx VersionRegex
    {
        get
        {
            if(versionRegex is not null)
                return versionRegex;
            versionRegex = new();
            versionRegex.Compile("^(?:PegLegResources\\-)?v(\\d+)\\.(\\d+)\\.(\\d+)([a-z]?[a-z0-9]*)(?:\\-Win64(?:.pck)?)?$");
            return versionRegex;
        }
    }

    static (int, int, int) GetVersion(string versionText)
    {
        if (VersionRegex.Search(versionText) is not RegExMatch standardMatch)
            return (0, 0, 0);
        var groups = standardMatch.Strings;
        int major = int.Parse(groups[1]);
        int minor = int.Parse(groups[2]);
        int patch = int.Parse(groups[3]);
        if (major.ToString() != groups[1])
        {
            GD.Print($"Incorect number format in Major version number ({major} != {groups[1]})");
            return (0, 0, 0);
        }
        if (minor.ToString() != groups[2])
        {
            GD.Print($"Incorect number format in Minor version number ({minor} != {groups[2]})");
            return (0, 0, 0);
        }
        if (patch.ToString() != groups[3])
        {
            GD.Print($"Incorect number format in Patch version number ({patch} != {groups[3]})");
            return (0, 0, 0);
        }
        return (major, minor, patch);
    }

    static void TryImportPackage(int major, int minor, int patch)
    {
        var packageFilename = $"PegLegResources-v{major}.{minor}.{patch}-Win64.pck";
        if (!FileAccess.FileExists(packageFolderPath + packageFilename))
            return;
        ProjectSettings.LoadResourcePack(packageFolderPath + packageFilename, false);
    }

    public static async Task ImportResources(string versionNumber)
    {
        var (majorTarget, minorTarget, patchTarget) = GetVersion(versionNumber);

        TryImportPackage(majorTarget, minorTarget, patchTarget);
        if (patchTarget != 0)
            TryImportPackage(majorTarget, minorTarget, 0);
        if (patchTarget != 0 && minorTarget != 0)
            TryImportPackage(majorTarget, 0, 0);
        await Task.WhenAll(
            LoadDataSources(),
            LoadNamedItems()
        );
    }

    //temporary until proper resource versioning system is ready
    public static async Task TempImportResources()
    {
        var tempPckPath = Helpers.GlobalisePath("res://PegLegResources.pck");
        if (FileAccess.FileExists(tempPckPath))
        {
            ProjectSettings.LoadResourcePack(tempPckPath, false);
        }
        await Task.WhenAll(
            LoadDataSources(),
            LoadNamedItems()
        );
    }

    static readonly string[] dataSourceNames = 
    [
        "AlterationLoadouts",
        "HeroStats",
        "ItemLevelsToXP",
        "ItemRatings",
        "MainQuestLines",
        "VenturesSeasons",
        "DifficultyInfo",
        "EventQuestLines",
        "ExpeditionCriteria",
    ];
    static async Task LoadDataSources()
    {
        ConcurrentDictionary<string, JsonObject> dataSourcesCC = [];
        var tasks = dataSourceNames.Select(name => Task.Run(() =>
        {
            dataSourcesCC.TryAdd(name, LoadResourceObj($"GameAssets/{name}.json"));
        }));
        await Task.WhenAll(tasks);
        dataSources = dataSourcesCC.ToFrozenDictionary(StringComparer.InvariantCultureIgnoreCase);
    }

    //todo: automate named item types by reading an index file generated by the exporter or the packager
    static readonly string[] itemTypeNames =
    [
        "Ability",
        "Accolades",
        "AccountResource",
        "Alteration",
        "Ammo",
        "CardPack",
        "CampaignHeroLoadout",
        "ConsumableAccountItem",
        "Defender",
        "Expedition",
        "Gadget",
        "GameplayModifier",
        "Hero",
        "HomebaseNode",
        "Ingredient",
        "MissionGen",
        "Quest",
        "Schematic",
        "TeamPerk",
        "Token",
        "Trap",
        "Weapon",
        "Worker",
        "WorkerPortrait",
        "WorldItem",
        "ZoneTheme",
    ];
    static async Task LoadNamedItems()
    {
        GD.Print("loading items");
        ConcurrentDictionary<string, GameItemTemplate> namedItemsCC = [];
        var tasks = itemTypeNames.Select(name => {
            var curName = name;
            return Task.Run(() =>
            {
                var itemData = LoadResourceObj($"GameAssets/NamedItems/{curName}.json", false).DetachAll();
                GD.Print($"loaded \"GameAssets/NamedItems/{curName}.json\", with {itemData.Count()} items");
                Parallel.ForEach(itemData, kvp =>
                {
                    namedItemsCC.TryAdd(kvp.Key, new(kvp.Value.AsObject()));
                });
            });
        });
        await Task.WhenAll(tasks);
        GameItemTemplate.SetImportedTemplates(namedItemsCC.ToFrozenDictionary(StringComparer.InvariantCultureIgnoreCase));
    }

    public static bool ResourceExists(string resource, bool allowOverrides = true)
    {
        return true;
    }

    static string[] externalResourceExclusions = 
    [
        "Themes/builtin_blank/"
    ];

    public static string[] LoadThemeList()
    {
        List<string> themeList = [];
        if(DirAccess.DirExistsAbsolute(fallbackResourcePath + "Themes"))
        {
            using var fallbackDir = DirAccess.Open(fallbackResourcePath + "Themes");
            var dirs = fallbackDir.GetDirectories();
            themeList.AddRange(dirs);
        }
        var indexedThemes = LoadResourceArray<string>("Themes/builtinThemeIndex.json", false).Select(s => "builtin_" + s);
        themeList.AddRange(indexedThemes);
        if(DirAccess.DirExistsAbsolute(overrideResourcePath + "Themes"))
        {
            using var overrideDir = DirAccess.Open(overrideResourcePath + "Themes");
            var dirs = overrideDir.GetDirectories();
            themeList.AddRange(dirs);
        }
        return themeList.Distinct().ToArray();
    }

    public static FileAccess LoadResourceFile(string resource, bool allowOverrides = true, bool onlyOverride = false)
    {
        bool exclude = externalResourceExclusions.Any(resource.StartsWith);
        if (allowOverrides && !exclude && FileAccess.FileExists(overrideResourcePath + resource))
        {
            return FileAccess.Open(overrideResourcePath + resource, FileAccess.ModeFlags.Read);
        }
        if (onlyOverride)
            return null;
        if (!exclude && FileAccess.FileExists(resourcePath + resource))
        {
            return FileAccess.Open(resourcePath + resource, FileAccess.ModeFlags.Read);
        }
        GD.Print("fallback file: " + fallbackResourcePath + resource);
        return FileAccess.Open(fallbackResourcePath + resource, FileAccess.ModeFlags.Read);
    }

    public static T LoadResourceObj<T>(string resource, bool allowOverrides = true) where T : class
    {
        using var standardFile = LoadResourceFile(resource, allowOverrides);
        try
        {
            return JsonSerializer.Deserialize<T>(standardFile.GetAsText());
        }
        catch { }
        return null;
    }
    public static T[] LoadResourceArray<T>(string resource, bool allowOverrides = true)
    {
        bool exclude = externalResourceExclusions.Any(resource.StartsWith);
        List<T> list = null;
        using (var standardFile = LoadResourceFile(resource, false))
        {
            try
            {
                list = [.. JsonSerializer.Deserialize<T[]>(standardFile.GetAsText())];
            }
            catch(JsonException e)
            {
                GD.PushWarning(e.Message);
            }
            catch { }
        }
        list ??= [];
        if (LoadResourceFile(resource, allowOverrides, true) is FileAccess overrideFile)
        {
            using var file = overrideFile;
            try
            {
                list.AddRange(JsonSerializer.Deserialize<T[]>(file.GetAsText()));
            }
            catch (JsonException e)
            {
                GD.Print($"Failed to load override for \"{resource}\",\n{e.Message}");
            }
            catch { }
        }
        return [.. list];
    }
    public static Dictionary<string, T> LoadResourceDict<T>(string resource, bool allowOverrides = true)
    {
        bool exclude = externalResourceExclusions.Any(resource.StartsWith);
        Dictionary<string, T> dict = null;
        using (var standardFile = LoadResourceFile(resource, false))
        {
            try
            {
                dict = JsonSerializer.Deserialize<Dictionary<string, T>>(standardFile.GetAsText());
            }
            catch (JsonException e)
            {
                GD.PushWarning(e.Message);
            }
            catch { }
        }
        dict ??= [];
        if (LoadResourceFile(resource, allowOverrides, true) is FileAccess overrideFile)
        {
            using var file = overrideFile;
            try
            {
                var overrides = JsonSerializer.Deserialize<Dictionary<string, T>>(file.GetAsText());
                dict = dict
                    .Where(kvp => !overrides.ContainsKey(kvp.Key))
                    .Union(overrides)
                    .ToDictionary();
            }
            catch (JsonException e)
            {
                GD.Print($"Failed to load override for \"{resource}\",\n{e.Message}");
            }
            catch { }
        }
        return dict;
    }

    public static JsonObject LoadResourceObj(string resource, bool allowOverrides = true)
    {
        bool exclude = externalResourceExclusions.Any(resource.StartsWith);
        string standardPath = !exclude && FileAccess.FileExists(resourcePath + resource) ? (resourcePath + resource) : (fallbackResourcePath + resource);
        JsonObject jObj = null;
        using (var standardFile = FileAccess.Open(standardPath, FileAccess.ModeFlags.Read))
        {
            try
            {
                jObj = JsonNode.Parse(standardFile.GetAsText()).AsObject();
            }
            catch { }
        }
        jObj ??= [];
        if (LoadResourceFile(resource, allowOverrides, true) is FileAccess overrideFile)
        {
            using var file = overrideFile;
            try
            {
                var overrides = JsonNode.Parse(file.GetAsText()).AsObject();
                foreach (var kvp in overrides.ToArray())
                {
                    jObj[kvp.Key] = overrides.DetachNode(kvp.Key);
                }
            }
            catch { }
        }
        return jObj;
    }
    public static JsonArray LoadResourceArray(string resource, bool allowOverrides = true)
    {
        bool exclude = externalResourceExclusions.Any(resource.StartsWith);
        string standardPath = !exclude && FileAccess.FileExists(resourcePath + resource) ? (resourcePath + resource) : (fallbackResourcePath + resource);
        JsonArray array = [];
        using (var standardFile = FileAccess.Open(standardPath, FileAccess.ModeFlags.Read))
        {
            try
            {
                array = JsonNode.Parse(standardFile.GetAsText()).AsArray();
            }
            catch { }
        }
        array ??= [];
        if (LoadResourceFile(resource, allowOverrides, true) is FileAccess overrideFile)
        {
            using var file = overrideFile;
            try
            {
                var toAdd = JsonNode.Parse(file.GetAsText()).AsArray().DetachAll();
                foreach (var node in toAdd)
                {
                    array.Add(node);
                }
            }
            catch { }
        }
        return array;
    }


    public static T LoadResourceAsset<T>(string resource, bool allowOverrides = true) where T : Resource
    {
        bool exclude = externalResourceExclusions.Any(resource.StartsWith);
        if (allowOverrides && !exclude && FileAccess.FileExists(overrideResourcePath + resource))
        {
            //todo: handle importing external resources and caching with weakrefs
            //return null;
        }
        if (!exclude && ResourceLoader.Exists(resourcePath + resource))
        {
            return ResourceLoader.Load<T>(resourcePath + resource);
        }
        if (ResourceLoader.Exists(fallbackResourcePath + resource))
        {
            return ResourceLoader.Load<T>(fallbackResourcePath + resource);
        }
        GD.PushWarning($"Asset not found: \"{resource}\"");
        return null;
    }

    public static JsonObject AlterationLoadouts => dataSources?["AlterationLoadouts"];
    public static JsonObject HeroStats => dataSources?["HeroStats"];
    public static JsonObject ItemLevelsToXP => dataSources?["ItemLevelsToXP"];
    public static JsonObject ItemRatings => dataSources?["ItemRatings"];
    public static JsonObject MainQuestLines => dataSources?["MainQuestLines"];
    public static JsonObject VenturesSeasons => dataSources?["VenturesSeasons"];
    public static JsonObject DifficultyInfo => dataSources?["DifficultyInfo"];
    public static JsonObject EventQuestLines => dataSources?["EventQuestLines"];
    public static JsonObject ExpeditionCriteria => dataSources?["ExpeditionCriteria"];

    //public static bool TryGetDataSource(string dataType, out JsonObject source)
    //{
    //    bool exists = dataSources.ContainsKey(dataType);
    //    if (!exists && TryLoadJsonFile(dataType, out var json))
    //    {
    //        dataSources[dataType] = source = json;
    //        return true;
    //    }
    //    source = exists ? dataSources[dataType] : null;
    //    return exists;
    //}

    //public static bool TryGetItemSource(string itemType, out JsonObject source)
    //{
    //    bool exists = itemSources.ContainsKey(itemType);
    //    if (!exists && TryLoadJsonFile("NamedItems/" + itemType, out var json))
    //    {
    //        itemSources[itemType] = source = json;
    //        return true;
    //    }
    //    source = exists ? itemSources[itemType] : null;
    //    return exists;
    //}

    //public static Texture2D GetReservedTexture(string texturePath)
    //{
    //    if (texturePath is null)
    //        return null;
    //    if (iconCache.ContainsKey(texturePath) && iconCache[texturePath].GetRef().Obj is Texture2D cachedTexture)
    //        return cachedTexture;

    //    string filePath = $"{banjoFolderPath}/{texturePath}";
    //    if(!FileAccess.FileExists(filePath))
    //    {
    //        //GD.PushWarning($"Missing Image file: {Helpers.ProperlyGlobalisePath(fullPath)}");
    //        return null;
    //    }
    //    Texture2D loadedTexture = ImageTexture.CreateFromImage(Image.LoadFromFile(filePath));
    //    //Texture2D loadedTexture = ResourceLoader.Load<Texture2D>(fullPath);
    //    iconCache[texturePath] = GodotObject.WeakRef(loadedTexture);

    //    return loadedTexture;
    //}

    //static bool TryLoadJsonFile(string fileName, out JsonObject json)
    //{
    //    json = null;
    //    string filePath = $"{banjoFolderPath}/{fileName}.json";
    //    if (!FileAccess.FileExists(filePath))
    //        return false;
    //    using FileAccess fileAccessor = FileAccess.Open(filePath, FileAccess.ModeFlags.Read);
    //    json = JsonNode.Parse(fileAccessor.GetAsText(), new() { PropertyNameCaseInsensitive = true }).AsObject();
    //    //GD.Print(fileName + " file loaded");
    //    return true;
    //}
}

public static class HeroStats
{
    public const string MaxHealth = "FortHealthSet.MaxHealth";
    public const string MaxShields = "FortHealthSet.Shield";
    public const string HealthRegenRate = "FortRegenHealthSet.HealthRegenRate";
    public const string ShieldRegenRate = "FortRegenHealthSet.ShieldRegenRate";
    public const string AbilityDamage = "FortDamageSet.OutgoingBaseAbilityDamageMultiplier";
    public const string HealingModifier = "FortHealthSet.HealingSourceBaseMultiplier";
}

public static class SurvivorBonus
{
    public const string MaxHealth = "IsFortitudeLow";
    public const string MaxShields = "IsResistanceLow";
    public const string ShieldRegenRate = "IsShieldRegenLow";

    public const string RangedDamage = "IsRangedDamageLow";
    public const string MeleeDamage = "IsMeleeDamageLow";
    public const string AbilityDamage = "IsAbilityDamageLow";
    public const string TrapDamage = "IsTrapDamageLow";

    public const string TrapDurability = "IsTrapDurabilityHigh";
}

public class GameItemTemplate
{
    #region Static Values

    static Texture2D goldLlama = ResourceLoader.Load<Texture2D>("res://Images/Llamas/PinataGold.png", "Texture2D");

    public static string[] rarityIds = new string[]
    {
        null,
        "C",
        "UC",
        "R",
        "VR",
        "SR",
        "UR"
    };

    public static string[] tierIds = new string[]
    {
        "T00",
        "T01",
        "T02",
        "T03",
        "T04",
        "T05",
    };

    public static readonly Color[] rarityColours = new Color[]
    {
        Colors.Transparent,
        Color.FromString("#bfbfbf", Colors.White),
        Color.FromString("#83db00", Colors.White),
        Color.FromString("#008bf1", Colors.White),
        Color.FromString("#a952ff", Colors.White),
        Color.FromString("#ff7b3d", Colors.White),
        Color.FromString("#ffff40", Colors.White),
    };

    static readonly string[] cardPackFromRarity = new string[]
    {
        "CardPack:cardpack_choice_all_r",
        "CardPack:cardpack_choice_all_r",
        "CardPack:cardpack_choice_all_r",
        "CardPack:cardpack_choice_all_r",
        "CardPack:cardpack_choice_all_vr",
        "CardPack:cardpack_choice_all_sr",
    };

    #endregion

    #region Static Methods

    static FrozenDictionary<string, GameItemTemplate> importedTemplates = null;
    public static void SetImportedTemplates(FrozenDictionary<string, GameItemTemplate> newImportedTemplates) =>
        importedTemplates = newImportedTemplates;

    static ConcurrentDictionary<string, GameItemTemplate> customTemplates = [];

    public static GameItemTemplate Get(string templateId)
    {
        if (templateId is null || templateId.Count(c => c == ':') != 1)
            return null;

        if (templateId.StartsWith("STWAccoladeReward"))
            templateId = templateId.Replace("STWAccoladeReward:stwaccolade_", "Accolades:accoladeid_stw_");

        if (templateId == "AccountResource:currency_mtxswap")
            templateId = "AccountResource:currency_hybrid_mtx_xrayllama";

        if (customTemplates.TryGetValue(templateId, out var custom))
            return custom;

        if (importedTemplates?.TryGetValue(templateId, out var imported) ?? false)
            return imported;

        return null;
    }

    public static GameItemTemplate GetOrCreate(string templateId, Func<GameItemTemplate> constructor)
    {
        if (templateId is null || templateId.Count(c => c == ':') != 1)
            return null;

        if (Get(templateId) is GameItemTemplate foundTemplate)
            return foundTemplate;

        GameItemTemplate newTemplate = constructor();

        if (newTemplate is not null)
            lock (customTemplates)
            {
                bool exists = customTemplates.TryAdd(newTemplate.TemplateId, newTemplate);
                return exists ? customTemplates[newTemplate.TemplateId] : newTemplate;
            }

        return null;
    }

    //probably pretty performance heavy, use sparingly
    public static GameItemTemplate[] GetTemplatesOfType(string templateType, Func<GameItemTemplate, bool> filter = null) => 
    [.. 
        importedTemplates?
        .Where(kvp =>
            kvp.Key.StartsWith(templateType + ":") &&
            (filter is null || filter(kvp.Value)
        ))?
        .Union(customTemplates
            .Where(kvp =>
                kvp.Key.StartsWith(templateType + ":") &&
                (filter is null || filter(kvp.Value)
            ))
        )?
        .Select(kvp => kvp.Value) ?? []
    ];

    public static Texture2D GetSubtypeTexture(string key, Texture2D fallbackIcon = null)
    {
        key ??= "";
        var dict = PegLegResourceManager.supplimentaryData.ItemTypeAndSubtypeIcons;
        if (dict.TryGetValue(key, out Texture2D value))
            return value;
        return fallbackIcon;
    }

    #endregion

    public GameItemTemplate(JsonObject rawData)
    {
        isReal = true;
        this.rawData = rawData;
    }

    public GameItemTemplate(string templateId = "Custom:item", string displayName = "Custom Item", string description = null, string iconPath = null, JsonObject extraData = null)
    {
        extraData ??= [];
        var splitTemplateId = templateId.Split(":");
        extraData["Type"] = splitTemplateId[0];
        extraData["Name"] = splitTemplateId[1];
        if (displayName is not null)
            extraData["DisplayName"] = displayName;
        if (description is not null)
            extraData["Description"] = description;
        if (iconPath is not null)
            extraData["ImagePaths"] = new JsonObject() { ["LargePreview"] = iconPath };
        rawData = extraData;
    }

    public bool isReal { get; private set; }
    public JsonObject rawData { get; private set; }
    public JsonNode this[string propertyName] => rawData[propertyName];
    public bool ContainsKey(string propertyName) => rawData.ContainsKey(propertyName);
    public string TemplateId => $"{Type}:{Name.ToLower()}";
    public bool VBucksOrXRayTickets => Type == "AccountResource" && Name.ToLower() is string lowername && (
            lowername == "currency_hybrid_mtx_xrayllama" ||
            lowername == "currency_mtxswap" ||
            lowername == "currency_xrayllama"
        );

    public string Type => rawData?["Type"].ToString();
    public bool IsCollectable => Type switch
    {
        "Hero" or "Worker" or "Defender" or "Schematic" => true,
        _ => false
    };
    public bool CanBeLeveled => Tier > 0 && Type switch
    {
        "Hero" or "Worker" or "Weapon" or "Trap" => true,
        "Schematic" => !Unrecyclable || Category != "Trap",
        "Defender" => !Unrecyclable,
        _ => false
    };
    public bool CanBeUnseen=> Type switch
    {
        "Hero" or "Worker" or "Defender" or "Schematic" or "Quest" or "AccountResource" or "ConsumableAccountItem" or "CardPack" => true,
        _ => false
    };

    public string CollectionProfile => Type == "Schematic" ? FnProfileTypes.SchematicCollection : FnProfileTypes.PeopleCollection;
    public string Name => rawData["Name"].ToString();
    public string DisplayName => rawData["DisplayName"]?.ToString();
    public string SortingDisplayName => DisplayName.StartsWith("The ") ? DisplayName[4..] : DisplayName;
    public string Description => rawData["Description"]?.ToString();
    public string Category => rawData["Category"]?.ToString();
    public string SubType => rawData["SubType"]?.ToString();
    public string Rarity => rawData["Rarity"]?.ToString();
    public int RarityLevel => (Rarity ?? "").ConvertRarityString();
    public Color RarityColor => Name.StartsWith("ZCP_") ? Colors.Transparent : rarityColours[RarityLevel];

    public int Tier => rawData["Tier"]?.GetValue<int>() ?? 0;
    //public int Tier => rawData["Tier"] is JsonValue tierVal ? (tierVal.TryGetValue<int>(out var tier) ? tier : 0) : 0;
    public string Personality => rawData["Personality"]?.ToString();

    public bool Unrecyclable => rawData["RecycleRecipe"] is null;
    public bool Undismantlable => rawData["DismantleResults"] is null;

    public JsonArray AlterationSlots
    {
        get
        {
            var row = rawData?["AlterationLoadoutRow"]?.ToString();
            if(row is null)
                return null;
            return PegLegResourceManager.AlterationLoadouts[row].AsArray();
        }
    }

    public string[] AlterationExclusions => rawData["AlterationNamedExclusions"]?.Deserialize<string[]>() ?? [];

    public Texture2D GetTexture(FnItemTextureType textureType = FnItemTextureType.Preview) => GetTexture(textureType, PegLegResourceManager.defaultIcon);
    public Texture2D GetTexture(Texture2D fallbackIcon) => GetTexture(FnItemTextureType.Preview, fallbackIcon);

    public Texture2D GetTexture(FnItemTextureType textureType, Texture2D fallbackIcon)
    {
        if 
        (
            (
                Type == "TeamPerk" || 
                Type == "Ability"
            ) && 
            textureType == FnItemTextureType.Preview
        )
            textureType = FnItemTextureType.Icon;

        if
        (
            Type == "Worker" &&
            (
                rawData["ImagePaths"]?
                ["SmallPreview"]?
                .ToString()
                .Contains("GenericWorker") ?? false
            )
        )
            return GetSubtypeTexture(SubType ?? "Survivor", fallbackIcon);

        if 
        (
            Type == "CardPack" && 
            textureType == FnItemTextureType.Preview && 
            DisplayName.Contains("Legendary") && 
            DisplayName.Contains("Llama") && 
            !Name.StartsWith("ZCP_")
        )
            return goldLlama;

        if (!TryGetTexturePath(out var texturePath, textureType))
            return fallbackIcon;
        return PegLegResourceManager.LoadResourceAsset<Texture2D>("GameAssets/"+texturePath) ?? fallbackIcon;
    }

    public bool TryGetTexturePath(out string foundPath, FnItemTextureType textureType = FnItemTextureType.Preview)
    {
        foundPath = null;
        JsonObject imagePaths = rawData["ImagePaths"]?.AsObject();
        if (imagePaths is null)
            return false;

        if (textureType == FnItemTextureType.Preview)
            foundPath = (imagePaths["LargePreview"] ?? imagePaths["SmallPreview"])?.ToString();
        else
            foundPath = imagePaths[textureType.ToString()]?.ToString();

        if (string.IsNullOrWhiteSpace(foundPath) || !foundPath.StartsWith("ExportedImages"))
            return false;
        return true;
    }

    public Texture2D GetSubtypeTexture(Texture2D fallbackIcon = null)
    {
        switch (Type)
        {
            case "Schematic":
                if (Category == "Trap")
                    return GetSubtypeTexture("Trap", fallbackIcon);
                else
                    return GetSubtypeTexture(SubType, fallbackIcon);
            case "Worker":
                if (rawData["ImagePaths"]?["SmallPreview"]?.ToString().Contains("GenericWorker") ?? false)
                    return null;
                else
                    return GetSubtypeTexture(SubType ?? "Survivor", fallbackIcon);
            case "Trap":
                return GetSubtypeTexture("Trap", fallbackIcon);
            default:
                return GetSubtypeTexture(SubType, fallbackIcon);
        }
    }

    public GameItemTemplate TryGetNextRarity()
    {
        if (rawData["RarityUpRecipe"]?["Result"]?.ToString() is string rarityUpResult)
            return Get(rarityUpResult);
        return null;
    }

    public GameItemTemplate TryGetNextTier()
    {
        if (rawData["TierUpRecipe"]?["Result"]?.ToString() is string rarityUpResult)
            return Get(rarityUpResult);
        return null;
    }

    public Texture2D GetAmmoTexture(Texture2D fallbackIcon = null)
    {
        if (Type != "Schematic" && Type != "Weapon" && Type != "Trap")
            return fallbackIcon;

        if (Category == "Trap" || Type == "Trap")
            return GetSubtypeTexture(SubType, fallbackIcon);

        if (
            rawData["RangedWeaponStats"]?["AmmoType"]?.ToString() is string ammoType && 
            PegLegResourceManager.supplimentaryData.AmmoIcons.ContainsKey(ammoType)
            )
            return PegLegResourceManager.supplimentaryData.AmmoIcons[ammoType];

        return fallbackIcon;
    }

    public string GetCompactRarityAndTier(int givenTier = 0)
    {
        var rarityId = rarityIds[RarityLevel];
        var tierId = givenTier <= 0 ? tierIds[Tier] : tierIds[givenTier];
        return rarityId + "_" + tierId;
    }

    GameItemTemplate[] heroAbilities;
    public GameItemTemplate[] GetHeroAbilities()
    {
        if (Type != "Hero")
            return null;
        return heroAbilities ??= new GameItemTemplate[]
        {
            Get(rawData["HeroPerkTemplate"]?.ToString()),
            Get(rawData["CommanderPerkTemplate"]?.ToString()),
            Get(rawData["HeroAbilities"]?[0].ToString()),
            Get(rawData["HeroAbilities"]?[1].ToString()),
            Get(rawData["HeroAbilities"]?[2].ToString()),
        };
    }

    GameItemTemplate teamPerk;
    public GameItemTemplate GetTeamPerk()
    {
        if (Type != "Hero")
            return null;
        return teamPerk ??= Get(rawData["UnlocksTeamPerk"]?.ToString());
    }

    GameItem[] questRewards;
    GameItem[] visibleQuestRewards;
    GameItem[] hiddenQuestRewards;
    public GameItem[] GetQuestRewards()
    {
        if (Type != "Quest")
            return null;
        return questRewards ??= GetVisibleQuestRewards().Union(GetHiddenQuestRewards()).ToArray();
    }

    public GameItem[] GetVisibleQuestRewards()
    {
        if (Type != "Quest")
            return null;
        return visibleQuestRewards ??= GenerateQuestRewards(false);
    }

    public GameItem[] GetHiddenQuestRewards()
    {
        if (Type != "Quest")
            return null;
        return hiddenQuestRewards ??= GenerateQuestRewards(true);
    }

    GameItem[] GenerateQuestRewards(bool hidden)
    {
        var allRewards = rawData["Rewards"]
            .AsArray()
            .Where(r => r["Hidden"].GetValue<bool>() == hidden);

        var rewards = allRewards
            .Where(r => !r["Selectable"].GetValue<bool>())
            .Select(r => Get(r["Item"].ToString())?.CreateInstance(r["Quantity"].GetValue<int>()))
            .Where(r => r is not null)
            .ToList();

        var dynamicRewards = allRewards
            .Where(r => r["Selectable"].GetValue<bool>());

        if (dynamicRewards.Any())
        {
            //fake a cardpack to show a choice reward
            var cardpackID = cardPackFromRarity[dynamicRewards.Select(q => Get(q["Item"]?.ToString())?.RarityLevel ?? 0).Max()];
            JsonObject attributes = new()
            {
                ["options"] = new JsonArray(dynamicRewards.Select(r => new JsonObject()
                {
                    ["itemType"] = r["Item"].ToString(),
                    ["attributes"] = new JsonObject(),
                    ["quantity"] = r["Quantity"].GetValue<int>()
                }).ToArray())
            };
            var choiceReward = Get(cardpackID).CreateInstance(1, attributes);
            choiceReward.attributes["quest_selectable"] = true;
            rewards.Insert(0, choiceReward);
        }
        return rewards.ToArray();
    }

    public JsonArray GenerateSearchTags(bool assumeUncommon = true)
    {
        if(rawData["searchTags"] is JsonArray existingSearchTags)
            return existingSearchTags.SafeDeepClone();

        List<string> tags =
        [
            DisplayName,
            Rarity ?? (assumeUncommon ? "Uncommon" : null),
            Type,
            SubType,
            Category,
            Personality?[2..]
        ];

        if(GetHeroAbilities() is GameItemTemplate[] abilities)
        {
            foreach (var ability in abilities)
            {
                if (!ability?.DisplayName?.EndsWith("+") ?? false)
                    tags.Add(ability.DisplayName);
            }
        }
        if(GetTeamPerk() is GameItemTemplate teamPerk)
            tags.Add(teamPerk.DisplayName);

        if (tags.Contains("Worker"))
            tags.Add("Survivor");
        if (rawData["RecycleRecipe"] is null)
            tags.Add("Permenant");
        var searchTags = new JsonArray(tags.Where(t => !string.IsNullOrWhiteSpace(t)).Select(t => (JsonNode)t).ToArray());
        lock (rawData)
        {
            rawData["RarityLv"] = RarityLevel;
            rawData["searchTags"] = searchTags;
        }
        return searchTags.SafeDeepClone();
    }

    public GameItem CreateInstance(int quantity = 1, JsonObject attributes = null, GameItem inspectorOverride = null, JsonObject customData = null)
    {
        customData ??= [];
        customData["generated_by_pegleg"] = true;
        return new(this, quantity, attributes, inspectorOverride, customData);
    }
}

public enum FnItemTextureType
{
    Preview,
    Icon,
    LoadingScreen,
    PackImage,

    Personality,
    SetBonus
}

class DataTable
{
    readonly Dictionary<string, DataTableCurve> curves = [];

    public DataTable(string filepath)
    {
        if (!FileAccess.FileExists(filepath))
            return;
        using FileAccess dataTableFile = FileAccess.Open(filepath, FileAccess.ModeFlags.Read);
        var curveJsonMap = JsonNode.Parse(dataTableFile.GetAsText())[0]["Rows"].AsObject();

        foreach (var curveKvp in curveJsonMap)
        {
            //GD.Print(survivorCurveKvp.Key);
            curves[curveKvp.Key] = new(curveKvp.Value.AsObject());
        }
    }
    public bool ContainsKey(string key) => curves.ContainsKey(key);
    public DataTableCurve this[string key] => curves[key];
}

class DataTableCurve
{
    readonly List<float> times = [];
    readonly List<float> values = [];
    readonly float minTime = 0;
    readonly float maxTime = 0;

    public DataTableCurve(string filepath, string curveKey)
    {
        using FileAccess dataTableFile = PegLegResourceManager.LoadResourceFile(filepath, false);
        if (dataTableFile is null)
            return;

        var curveJsonMap = JsonNode.Parse(dataTableFile.GetAsText())[0]["Rows"].AsObject();

        if (!curveJsonMap.ContainsKey(curveKey))
            return;

        var dataTableCurveJson = curveJsonMap[curveKey].AsObject();

        var keysArray = dataTableCurveJson["Keys"].AsArray();

        minTime = keysArray[0]["Time"].GetValue<float>();
        maxTime = keysArray[^1]["Time"].GetValue<float>();

        foreach (var curvePointKey in keysArray)
        {
            times.Add(curvePointKey["Time"].GetValue<float>());
            values.Add(curvePointKey["Value"].GetValue<float>());
        }
    }

    public DataTableCurve(JsonObject dataTableCurveJson)
    {
        var keysArray = dataTableCurveJson["Keys"].AsArray();
        minTime = keysArray[0]["Time"].GetValue<float>();
        maxTime = keysArray[^1]["Time"].GetValue<float>();

        foreach (var curvePointKey in keysArray)
        {
            times.Add(curvePointKey["Time"].GetValue<float>());
            values.Add(curvePointKey["Value"].GetValue<float>());
        }
    }

    public float Sample(float time)
    {
        if (time < minTime)
        {
            //handle pre-infinity
            return values[0];
        }
        if (time > maxTime)
        {
            //handle post-infinity
            return values[^1];
        }

        // higher/lower search for time range
        int GetClosestTimeIndexFloored(int fromIndex, int toIndex, float time)
        {
            if (toIndex - fromIndex < 3)
            {
                toIndex = Mathf.Clamp(toIndex, 0, times.Count);
                while (time <= times[toIndex] && toIndex>0)
                    toIndex--;
                return toIndex;
            }

            int middleIndex = Mathf.CeilToInt((toIndex - fromIndex) * 0.5f) + fromIndex;

            if (time == times[middleIndex])
                return middleIndex;
            else if (time > times[middleIndex])
                return GetClosestTimeIndexFloored(middleIndex, toIndex, time);
            else
                return GetClosestTimeIndexFloored(fromIndex, middleIndex, time);
        }

        int lowerIndex = GetClosestTimeIndexFloored(0, times.Count - 1, time);

        float lowerTime = times[lowerIndex];
        float upperTime = times[lowerIndex + 1];

        float betweenTimeBlend = (time - lowerTime) / (upperTime - lowerTime);

        float lowerValue = values[lowerIndex];
        float upperValue = values[lowerIndex + 1];

        return lowerValue + ((upperValue - lowerValue) * betweenTimeBlend);
    }
}